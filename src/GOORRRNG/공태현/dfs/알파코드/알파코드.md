### 문제

---

철수와 영희는 서로의 비밀편지를 암호화해서 서로 주고받기로 했다.

그래서 서로 어떻게 암호화를 할 것인지 의논을 하고 있다.

영희 : 우리 알파벳 A에는 1로, B에는 2로 이렇게 해서 Z에는 26을 할당하여 번호로 보내기로 하자.

철수 : 정말 바보같은 생각이군!! 생각해 봐!! 만약 내가 “BEAN"을 너에게 보낸다면 그것을 암호화하면 25114이잖아!! 그러면 이것을 다시 알파벳으로 복원할 때는 많은 방법이 존재하는 데 어떻게 할건데... 이것을 알파벳으로 바꾸면 BEAAD, YAAD, YAN, YKD 그리고 BEKD로 BEAN말고도 5가지나 더 있군.

당신은 위와 같은 영희의 방법으로 암호화된 코드가 주어지면 그것을 알파벳으로 복원하는데 얼마나 많은 방법이 있는지 알고싶다.

매개변수 s에 암호화된 숫자가 문자열형태로 주어지면 이것을 알파벳으로 복원하는 방법의 가 지수를 반환하는 프로그램을 작성하라.

### 입출력 예

---

<img width="554" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202024-04-05%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201 29 43" src="https://github.com/runtime-zer0/goorrrng/assets/147473025/65eeb8c1-3c01-4248-8480-feb9f5b5b9d0">

### 제한사항

---

- 문자열 s의 길이는 50를 넘지 않습니다.
- 문자열 s는 숫자로만 구성되어 있습니다.

### 문제 접근

---

해당 문제는 주어진 문자열을 순차적으로 탐색하면서 탐색한 문자열을 정수로 변환했을때, 각 알파벳을 의미하는 1부터 26까지의 수라면 해당 문자열은 알파벳으로 변환 가능한 수이므로 카운팅해나가며 문제에서 주어진 문자열을 알파벳으로 복원하는 방법의 모든 가지수를 출력하는 문제다.

DFS를 활용하여 TOP - DOWN 방식으로 메모이제이션을 활용해서 중복되는 계산은 하지 않을것이며, 알파벳으로 변환할때 1 부터 26까지의 수만 변환 가능하므로 자릿수는 1자리 아니면 2자리다.

하지만 2자리를 탐색했다고 무조건 알파벳으로 변환가능하지 않을수도 있으므로 1갈래 또는 2갈래로 가지를 뻗으면서 탐색을 진행할것이다.

아래와 같이 풀것이다.

1. 해당 노드에 대한 값이 이미 계산되어있는지 확인하고 계산되어있다면 더이상 탐색을 진행하지 않고 이미 계산되어 있는 값을 반환한다.

    <aside>
    💡 메모이제이션을 활용하여 문제를 풀것이기 때문에 이미 계산되어 기록되어있는 값이라면 더이상 탐색을 진행할 필요없이 계산되어 기록되어있는 값만 반환하면 된다.

    </aside>

2. 탐색중인 문자의 시작 문자가 ‘0’ 인지 확인하고 만약 ‘0’이라면 알파벳으로 변환할 수 없으므로 0을 히턴
3. 현재 탐색중인 위치가 주어진 문자열의 마지막 인덱스이거나 마지막 인덱스 + 1 위치를 탐색하고 있다면 1을 리턴한다.

    <aside>
    💡 탐색을 진행할때 1자리 또는 최대 2자리에 대한 경우의 수를 계산할 수 있다.

   현재 탐색중인 위치가 주어진 문자열의 길이를 1 넘어섰거나, 현재 탐색중인 위치가 문자열의 마지막 위치라면 마지막 문자열을 탐색한다는 의미이므로 경우의 수는 무조건 한개다.

   따라서 해당 경우에서는 1을 리턴한다.

    </aside>

4. 1자리만 탐색하는 경우의 수에 대한 탐색을 진행하고 반환 값을 저장한다.
5. 2자리에 대한 탐색을 진행하기전에 2자리 문자열을 정수로 변환하고 1부터 26까지의 수라면 2자리를 탐색하는 경우의 수에대한 탐색을 진행하고 반환된 값을 4번에서 계산한 값과 더해서 저장한다.
6. 메모이제이션을 활용하여, 현재 탐색중인 위치를 인덱스로 하는 위치에다가 5번에서 계산한 값을 배열에 저장한다.

### 체크포인트

---

- **탐색 방법**

    ```java
    1부터 26까지의 수만 알파벳으로 변환할 수 있기 때문에 한번에 1자리 또는 2자리에 대한 탐색을 진행할 수있다. 
    따라서, 최소 1갈래 또는 최대 2갈래로 가지를 뻗으면서 탐색을 진행하므로 루프를 활용할 필요없이 부분 집합을 구성할때처럼 함수를 2번 호출하면 된다.  
    ```

- **문자 ‘0’ 에 대한 처리**

    ```java
    1부터 26까지의 수만 알파벳으로 변환 가능하므로 '0'으로 시작하는 문자를 탐색할 경우에는 변환할수있는 경우의 수가 없으므로 0을 리턴한다.
    ```

- **메모이제이션 활용**

    ```java
    해당 문제는 피보나치 수열을 계산하는것 처럼 TOP - DOWN 방식으로 문제를 해결한다.
    피보나치 수열을 계산하는것과 마찬가지로 해당 문제도 계산의 중복이 발생한다.
    따라서 이미 계산된 항에 대해서는 배열에 기록해두고 이미 기록되어있는 항이라면 더이상 탐색을 진행하지 않고 배열에서 계산되어있는 해당 항에 대한 값을 리턴하는 피보나치 수열 문제처럼, 해당 문제도 경우의 수가 계산될때마다 배열에 값을 기록하여 중복된 계산에 대한 탐색을 진행하게되면 탐색을 진행하지 않고 배열에 기록되어있는 값을 리턴하는 방식으로 시간복잡도를 최소화하면서 문제를 풀것이다.  
    ```


---

위의 내용을 바탕으로 아래와 같이 풀것이다.

1. 탐색시작

    ```java
    return DFS(0, s);
    ```

2. 탐색중인 위치의 경우의수가 이미 계산되어있다면 더이상 탐색을 진행하지 않고 현재 탐색중인 위치를 인덱스로하는 배열에 저장된 값을 리턴.

    ```java
    if (memo[start] != 0) {
        return memo[start];
    }
    ```

3. 만약 탐색중인 위치의 값이 ‘0’으로 시작한다면 알파벳으로 변환하는 경우의 수를 계산할 수 없으므로 0을 리턴

    ```java
    if (start < str.length() && str.charAt(start) == '0') {
        return 0;
    }
    ```

4. 만약 문제에서 주어진 문자열의 마지막 위치를 탐색중이거나 2자리 탐색으로 인해서 주어진 문자열을 위치를 1만큼 벗어났다면, 문제에서 주어진 문자열에서 마지막 문자열을 탐색하는것이므로 마지막으로 탐색가능한 문자를 알파벳으로 변환하는 경우의 수는 무조건 1개다.

   따라서 1을 리턴.

    ```java
     if (start == str.length() - 1 || start == str.length()) {
        return 1;
    ```

5. 한자리 수에대한 탐색 결과를 res에 저장

    ```java
    else {
            int res = DFS(start + 1, str);
    ```

6. 두자리에 대한 탐색도 진행해야 하므로 시작위치를 포함한 2자리 문자열을 정수로 변환후 1부터 26까지의 수인지 확인하고 해당 조건을 만족한다면 2자리 문자열에 대한 탐색을 진행하고 반환된 값을 5에서 계산한 결과값에 더한다.

    ```java
    int tmp = Integer.parseInt(str.substring(start, start + 2));
    if (tmp <= 26) {
        res += DFS(start + 2, str);
    }
    ```

7. res에 저장된 값이 현재 탐색중인 문자를 시작으로 하는 알파벳으로 변환가능한 경우의 수이므로 현재 탐색중인 위치를 인덱스로 하는 배열에 res를 저장함으로써, 계산의 중복이 발생한다면 탐색을 진행하지 않고 배열에 저장되어있는 값만 반환하면서 시간복잡도를 최소화한다.

    ```java
    return memo[start] = res;
    ```


### 코드

---

```java
static int[] memo;
    
public static int DFS(int start, String str) {
    if (memo[start] != 0) {
        return memo[start];
    }
    
    if (start < str.length() && str.charAt(start) == '0') {
        return 0;
    }
    
    if (start == str.length() - 1 || start == str.length()) {
        return 1;
    } else {
        int res = DFS(start + 1, str);
        
        int tmp = Integer.parseInt(str.substring(start, start + 2));
        if (tmp <= 26) {
            res += DFS(start + 2, str);
        }
        
        return memo[start] = res;
    }
}

public static int solution(String s){
    memo = new int[s.length() + 1];

    return DFS(0, s);
}
```