### 문제

---

현수네 반 총 인원수는 7명이다.

오늘은 운동회 날로 반대항 줄다리기 시합이 있다.

현수네 반 총 인원인 7명이 모두 줄다리기에 출전한다.

선생님은 줄다리기를 하기 위해 7명을 일렬로 세우는데 서로 싫어하는 학생끼리 이웃하게 일 렬로 세우면 경기력이 저하되어 정상적인 경기력이 나오지 않는다.

매개변수 nums에 현수네 반 학생의 서로 싫어하는 정보가 주어지면 서로 싫어하는 학생끼리 이웃하지 않게 줄을 세우는 경우수를 알고싶다.

즉, 정상적인 경기력으로 줄다리기를 하기 위해 7명을 일렬로 세울 수 있는 모든 방법의 수를 구해 반환하는 프로그램을 작성하라.

### 입출력 예

---

<img width="783" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202024-04-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011 06 54" src="https://github.com/runtime-zer0/goorrrng/assets/147473025/0a2b0186-7747-467b-8ba0-ff0af16d80c1">

- 예제 1번 설명

  만약 1 2 4 3 5 6 7 로 일렬로 세운다면 2번과 4번이 서로 싫어해서 정상적인 경기력이 나오지 않는다.

  만약, 1 2 3 4 5 7 6 로 일렬로 세운다면 5번과 7번이 서로 싫어해서 정상적인 경기력이 나오지 않는다.

  만약, 1 2 3 4 5 6 7 로 일렬로 세운다면 서로 싫어하는 사람이 이웃하지 않아서 정상적인 경기력이 나온다.


### 제한사항

---

- nums의 길이는 20을 넘지 않는다.
- 각 학생은 1번부터 7번까지 고유번호로 인식된다.

### 문제 접근

---

문제에서 1번부터 7번까지의 학생을 나란히 세우는 모든 방법의 수를 구하라고 했으므로 DFS를 활용하여 1부터 7까지의 수를 활용해 문제의 조건에 맞는 순열을 구성하는 경우의수를 계산하는 문제다.

단순히 DFS를 활용하여 순열을 구성하는것에서 문제에서 요구하는대로 약간의 구현도 필요한 문제다.

아래와 같이 풀것이다.

1. 문제에서 주어진 값을 바탕으로 친하지 않은 친구의 번호를 표시하기위해 인접 행렬을 구성하듯이 2차원 배열을 생성하고 친하지 않은 친구를 탐색할때 마다 해당 학생의 번호에 해당하는 배열의 원소를 1로 초기화한다.

    <aside>
    💡 만약, [1, 3]을 탐색하면 배열[1][3], 배열 [3][1]에 1로 초기화한다.

   배열[3][1]도 1로 초기화 하는 이유는 [1, 3] 에 해당은 학생이 친하지 않다면 순열을 구성했을때 1, 3, 7나 3, 1, 7 둘다 줄다리기 할때 힘을 발휘 할수 없는 순서이므로 일단 1, 3 이 서로 인접해있다면 순열을 구성할 필요가 없다.

    </aside>

2. 문제에서 요구하는대로 1부터 7까지의 정수를 바탕으로 순열을 구성한다.
3. 순열을 구성할때 1에서 구성한 배열을 바탕으로 배열의 원소가 1이 아닌 경우에만, 스택을 활용하여 순열을 구성한다.
4. 7개의 원소로 이루어진 순열 구성을 완료했다면 answer 문제에서 요구하는 순열 1개를 구성한것이므로 answer 값을 1 증가시킨다.

### 체크포인트

---

- **주어진 값을 바탕으로 친하지 않은 친구들의 정보를 저장하는 배열 생성**

    ```java
    문제에서 친하지 않은 친구의 번호가 주어질때마다 해당 학생들의 번호에 해당하는 원소를 1로 초기화하여 두 친구는 친하지 않은 친구임을 알수 있도록 한다.
    ```

- **순열을 구성할때 배열이 아닌 스택을 활용**

    ```java
    1부터 7까지의 수로 수열을 구성할때 마다, 친하지 않은 친구의 정보가 저장되어있는 배열을 탐색하여 친하지 않은 친구인지 확인하면서 순열을 구성한다.   
    ```


---

위의 내용을 바탕으로 아래와 같이 풀것이다.

1. 문제에서 주어진 입력값을 바탕으로 각 자리수를 분리하고 순차적으로 정수형 배열에 저장

    ```java
    relation = new int[8][8];
        
    for(int[] val : state){
        relation[val[0]][val[1]] = 1;
        relation[val[1]][val[0]] = 1;
    }
    ```

2. 중복 순열을 구성하지 않도록 체크하기 위한 배열을 초기화하고 탐색시작

    ```java
    visited = new boolean[8];
        
    DFS(0);
    ```

3. 문제에서 요구하는 조건에 맞는 순열을 구성했다면 answer 값 1 증가

    ```java
    if(level == 7){
        answer++;
    }
    ```

4. 문제에서 요구하는 순열을 구성하지 못했다면, 친하지 않은 친구의 정보가 저장되어있는 배열을 탐색하면서 문제에서 요구하는 순열을 구성한다.

    ```java
    for(int i = 1; i < 8; i++){
    		if(!pm.isEmpty() && relation[pm.peek()][i] == 1){
    		    continue;
    		}
    ```

5. 만약 친하지 않은 친구의 정보가 저장되어 있는 배열을 탐색하여 순열을 구성할 수있는 경우라면 현재 탐색중인 원소가 이미 순열로 구성되어있는지 확인하고 아직 순열로 구성되지 않은 원소라면 스택에 저장하여 순열을 구성하고 다음 원소를 탐색

    ```java
    if(!visited[i]){
        visited[i] = true;
        pm.push(i);
        DFS(L + 1);
        visited[i] = false;
        pm.pop();
    }
    ```


### 코드

---

```java
static boolean[] visited;
static int[][] relation;
static int answer;
static Deque<Integer> pm;

public static void DFS(int level){
    if(level == 7){
        answer++;
    }
    else{
        for(int i = 1; i < 8; i++){
            if(!pm.isEmpty() && relation[pm.peek()][i] == 1){
                continue;
            }
            if(!visited[i]){
                visited[i] = true;
                pm.push(i);
                DFS(L + 1);
                visited[i] = false;
                pm.pop();
            }
        }
    }
}

public static int solution(int[][] state){
    answer = 0;
    pm = new LinkedList<>();
    relation = new int[8][8];
    
    for(int[] val : state){
        relation[val[0]][val[1]] = 1;
        relation[val[1]][val[0]] = 1;
    }
    visited = new boolean[8];
    
    DFS(0);
    return answer;
}
```