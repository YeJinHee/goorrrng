### 문제

---

매개변수 s에 숫자로 구성된 문자열이 주어지면 이 문자열을 이용하여 유효한 IP주소의 경우 들을 찾고 싶다.

만약 문자열 s = "2025505" 이 주어지면 만들 수 있는 유효한 IP 주소는 ["20.25.50.5","20.255.0.5","202.5.50.5","202.55.0.5"] 와 같다.

1) IP 주소는 4개의 숫자가 . 로 구분되어 있다.

2) IP 주소의 4개의 숫자는 0 ~ 255사이의 숫자로 구성된다,

(0, 255포함)3) IP 주소의 4개의 숫자는 0으로 시작하는 2자리 이상의 숫자는 안됩니다.위에 입력의 경우 "2.0.255.0.5"와 같이 5개로 구성되어 있거나, "2.025.50.5"와 같이 0으로 시작하거나, "20.2.5.505"와 같이 255보다 큰 숫자가 존재하거나 하면 안된다.

매개변수 s에 숫자로 구성된 문자열이 주어지면 이 문자열을 이용하여 유효한 IP주소의 경우 들을 배열에 담아 반환하는 프로그램을 작성하라.

배열에 담는 순서는 상관없다.

매개변수 s의 숫자들의 순서를 임의로 바꾸거나, 숫자를 지워서는 안된다.

만들 수 있는 유효한 IP가 없을 경우 빈 배열을 반환한다.

### 입출력 예

---

<img width="548" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202024-04-04%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207 18 20" src="https://github.com/runtime-zer0/goorrrng/assets/147473025/0df626f2-c326-434e-a6a4-37b3edba427f">

### 제한사항

---

- 문자열 s의 길이는 16를 넘지 않습니다.
- 문자열 s는 숫자로만 구성되어 있습니다.

### 문제 접근

---

해당 문제는 주어진 문자열을 순차적으로 탐색하면서 0 ~ 255 까지의 숫자로 변환한뒤 문제에서 요구하는 조건에 맞는 IP 주소 문자열을 구성하는 문제다.

DFS를 활용하여 ,IP 주소 문자열을 구성할때 배열이 아닌 스택을 활용하여 문제에서 요구하는 IP 주소 문자열을 구성할 것이다.

아래와 같이 풀것이다.

1. 문제에서 요구하는 IP 주소 문자열은 ‘ . ’ 으로 구분된 4개의 숫자 문자열로 구성되어있기 때문에 스택에 저장되어있는 원소의 갯수가 4개인지를 확인한다.

   또한, 현재 접근중인 원소의 인덱스와 문제에서 주어진 문자열의 길이가 같은지 확인한다.

    <aside>
    💡 문제에서 주어진 문자열을 모두 활용해야 하기 때문에 현재 접근중인 원소의 인덱스가 문제에서 주어진 문자열의 길이와 같아야 문제에서 요구하는 IP 주소를 구성했다는 의미다.

    </aside>

2. 1번 조건을 만족하면 문제에서 요구하는 형식으로 구성한 IP 주소를 가공하고 리스트에 저장한다.
3. 문제에서 요구하는 IP 주소를 구성하지 못했다면 루프를 활용하여 문제의 조건에 맞는 부분 IP 주소 숫자를 구성한다.

    <aside>
    💡 구성하려는 부분 IP 문자열의 시작 문자열이 ‘0’이고 문자열의 길이가 2라면 문제에서 요구하는 IP 문자열을 구성할 수 없으므로 해당 문자에대한 탐색을 종료한다. 또한 구성한 부분 IP 숫자가 255 보다 크면 문제에서 요구하는 IP 주소 문자열을 구성할 수 없으므로 해당 문자에 대한 탐색을 종료한다.

    </aside>

4. 루프를 돌면서 문제에서 요구하는 조건을 만족하는 부분 IP 숫자를 구성한다면 스택에 저장하여 문제에서 요구하는 IP 주소 문자열을 구성한다.

### 체크포인트

---

- **탐색 종료 조건**

    ```java
    1. 문제에서 요구하는 IP 주소 문자열은 ‘ . ’ 으로 구분된 4개의 숫자 문자열로 구성되어있기 때문에 스택에 저장되어있는 원소의 갯수가 4개인지를 확인한다.
    
    2. 또한, 현재 접근중인 원소의 인덱스가 문제에서 주어진 문자열의 길이와 같아야 문제에서 요구하는 IP 주소를 구성했다는 의미이므로 문제에서 주어진 현재 탐색중인 원소의 인덱스가 문자열의 길이와 같은지도 확인한다.  
    ```

- **부분 IP 주소 구성 조건**

    ```java
    1. 문제에서 주어진 문자열을 순차적으로 탐색하면서 구성하려는 부분 IP 문자열의 시작 문자열이 ‘0’이고 문자열의 길이가 2라면 문제에서 요구하는 IP 문자열을 구성할 수 없으므로 해당 문자에대한 탐색을 종료한다. 
    
    2. 또한 구성한 부분 IP 숫자가 255 보다 크면 문제에서 요구하는 IP 주소 문자열을 구성할 수 없으므로 해당 문자에 대한 탐색을 종료한다.
    
    두개의 조건을 확인하면서 문제에서 부분 IP 주소를 구성해나가면서 문제에서 요구하는 IP 주소 문자열을 구성한다.
    ```


---

위의 내용을 바탕으로 아래와 같이 풀것이다.

1. 탐색시작

    ```java
     DFS(0, s);
    ```

2. 문제에서 요구하는 IP 주소 문자열을 구성했는지 확인하고 만약, 문제에서 요구하는 문자열을 구성했다면 문제에서 요구하는 형식에 맞는 문자열로 가공하고 리스트에 저장한다.

    ```java
     if (stack.size() == 4 && start == str.length()) {
        StringBuilder sb = new StringBuilder();
        
        for (Integer val : stack) {
            sb.append(val).append(".");
        }
        
        res.add(sb.substring(0, sb.length() - 1));
    }
    ```

3. 만약, 문제에서 요구하는 IP 주소 문자열을 구성하지 못했다면 루프를 활용하여 문제에서 요구하는 조건에 맞는 부분 IP 주소를 구성해나간다.

   만약 문제에서 요구하는 조건에 맞는 부분 IP 주소를 구성했다면 스택에 저장한다.

   루프를 활용하여, 1번 조건을 만족할때까지 부분 IP 주소를 구성한다.

    ```java
    else {
        for (int i = start; i < str.length(); i++) {
            if (str.charAt(start) == '0' && i > start) {
                return;
            }
            
            int num = Integer.parseInt(str.substring(start, i + 1));
            if (num > 255) {
                return;
            }
            
            stack.offer(num);
            DFS(i + 1, str);
            stack.pollLast();
        }
    }
    ```


### 코드

---

```java
 static Deque<Integer> stack;
static List<String> res;

public static void DFS(int start, String str) {
    if (stack.size() == 4 && start == str.length()) {
        
        StringBuilder sb = new StringBuilder();        
        for (Integer val : stack) {
            sb.append(val).append(".");
        }
        
        res.add(sb.substring(0, sb.length() - 1));
    } else {
        for (int i = start; i < str.length(); i++) {
            if (str.charAt(start) == '0' && i > start) {
                return;
            }

            int num = Integer.parseInt(str.substring(start, i + 1));
            if (num > 255) {
                return;
            }

            stack.offer(num);
            DFS(i + 1, str);
            stack.pollLast();
        }
    }
}

public static String[] solution(String s){
    stack = new LinkedList<>();
    res = new ArrayList<>();
    
    DFS(0, s);

    String[] answer = new String[res.size()];
    for (int i = 0; i < res.size(); i++) {
        answer[i] = res.get(i);
    }
    
    return answer;
}
```