### 문제

---

현수는 송아지를 잃어버렸다.

다행히 송아지에는 위치추적기가 달려 있다.

현수의 현 재 위치와 송아지의 현재 위치가 수직선상의 좌표 점으로 주어진다.

송아지는 매초 처음 위치에서 (이전이동거리+1)만큼 이동한다. 송아지의 처음 이동거리는 1 이다.

현수는 송아지를 잡기 위해 스카이 콩콩을 타고 가는데 현재 현수의 위치가 x라면 매초 앞으 로 x + 1, 뒤로 x - 1, 앞으로 x * 2 위치로 이동할 수 있다.

매개변수 s에 현수의 시작위치, 매개변수 e에 송아지의 시작위치가 주어지면, 현수가 송아지를 잡는 가장 빠른 시간을 반환하는 프로그램을 작성하라.

현수의 위치와 송아지의 위치가 같으면 잡는 것으로 간주한다.

### 입출력 예

---

<img width="431" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202024-04-12%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012 30 48" src="https://github.com/runtime-zer0/goorrrng/assets/147473025/97dc56f9-8205-4269-86e6-781e017b8a60">

- 예제 1번 설명

  (1, 2, 3, 4, 8, 16, 32)--현수의 이동경로(11, 12, 14, 17, 21, 26, 32)--송아지의 이동경로


### 제한사항

---

- 수직선의 좌표는 0부터 200,000까지입니다.
- s != e
- 만약 송아지가 수직선상의 좌표 200,000을 넘어가면 송아지를 못 잡는 걸로 간주하고 -1를 반환합니다.

### 문제 접근

---

뭔가 쉬운듯 하면서 쉽지 않은 문제다.

레벨 탐색(BFS)을 활용하여 풀 수 있는 문제라 쉽게 풀수 있을거라 생각했지만 조금더 생각해야할 것이 있는 문제다.

만약에 송아지의 위치가 변경되지 않고 고정되어있다면 정말 쉽게 풀었겠지만 송아지가 움직이기 때문에 생각해야할 것이 많다. 송아지의 위치가 고정이 되어있다면 한번 방문한 위치를 방문할 두번은 방문할 필요가 없지만 매초 송아지가 움직이기 때문에 한번 방문한 위치에 송아지가 없었더라도 새로운 시간에 방문했을때 동일한 위치에 송아지가 있을 수 있기 때문에 해당 위치에 대한 중복 방문을 허용해야 한다.

하지만, 송아지의 위치가 변경되는것에 대한 구현을 했더라도 좌표가 최대 200,000 이기 때문에 단순하게 모든 방문 가능한 위치에 대해 탐색을 진행하면서 문제를 풀면 시간초과가 날것이다.

<aside>
💡 그래서 탐색을 진행할때 홀수레벨 탐색, 짝수레벨 탐색을 구분하여 visited 배열에 방문 여부를 체크할것이다. 왜냐하면 예를들어 1레벨때 방문한 노드는 3레벨에서도 동일하게 방문을 하고 3레벨때 방문한 노드는 5레벨에서 동일하게 방문을한다. **한마디로 중복으로 방문을 한다는 의미다.  이미 해당 레벨에서 해당 위치를 방문할 수 있는 사실을 알고 있는데도 방문하려는 위치를 큐에 저장할 필요가 없다.** 그래서 해당 레벨에서 방문한 위치가 이미 방문한 위치라면 이미 방문을 했으므로, 해당 레벨에서 해당 위치를 방문하지 못한다는 의미가 아니라, 이미 해당 레벨에서 해당 위치를 방문할 수 있다는 사실을 알고 있으므로 방문하려는 위치를 단순하게 큐에만 저장하지 않는다는 의미다. **시간복잡도를 줄이기 위해서다.** 그러니까 **해당 문제에서 visited 배열의 역할은 단순하게 방문했는지 안했는지에 대한 체크를 하는것이 아니라 해당 레벨에서 현재 위치에 방문할 수 있는지 없는지를 체크**하는 것이다.

</aside>

그래서 시간초과가 나지 않도록 현재 시간이 아닌 과거에 방문한 위치의 체크 여부를 바탕으로, 과거에 동일한 위치에 방문 표시가 되어있다면

### 체크포인트

---

- **하나의 위치에 중복 방문 허용**

    ```java
    송아지의 위치가 고정이 되어있다면 한번 방문한 위치를 방문할 두번은 방문할 필요가 없지만 매초 송아지가 움직이기 때문에 한번 방문한 위치에 송아지가 없었더라도 새로운 시간에 방문했을때 동일한 위치에 송아지가 있을 수 있기 때문에 해당 위치에 대한 중복 방문을 허용해야 한다.
    ```

- **visited 배열의 역할**

    ```java
    visited 배열을 단순하게 방문여부만 체크 하는것이 아니라, 송아지의 위치가 고정되어있지 않기 떄문에,  동일한 위치의 중복 방문을 허용한다. 따라서 visited 배열을 i 초에 해당 위치를 방문할 수 있는지를 체크하는 용도로 활용해야한다. 한마디로 visited 배열의 역할은 i 초에 해당 위치를 방문할 수 있는지를 확인하기 위한것이다.
    ```

- **visited 배열의 홀수초 짝수초로 분리해서 체크**

    ```java
    예를 들어, 5초에 방문하려는 위치는 1초, 3초 시점에 탐색한 위치들을 모두 중복으로 방문하게 된다. 그래서 중복 방문은 허용하되 5초 시점에서 1초 3초 시점에 탐색을 진행하여 이미 방문 체크 되어있는 위치를 중복으로 탐색할 필요가 없는것이다. 이미 5초 시점에 방문하려는 위치의 일부분은 1초 3초 시점에 방문 체크가 되어있고, 무조건 방문해야하기 때문에, 5초 시점에서는 1초 3초 시점에서 방문할 수 없는 새로운 위치에 대해서만 큐에 저장해서 탐색을 진행하면 된다는 의미다. 쉽게 말해, 5초때 방문하려는 위치가 이미 1초 3초때 방문한 위치라면 굳이 큐에 저장하여 중복으로 탐색을 진행하지 않아도 된다는 의미다. 이는 2초 4초 6초와 같이 짝수 시점에서도 동일하기 때문에 홀수초 짝수초로 분리해서 visited 배열을 체크할 것이다.
    ```


---

아래와 같이 풀것이다.

1. 방문여부를 체크하는 배열을 1차원 배열이 아닌 2차원 배열로 생성한다.

   홀수초 짝수초 구분해서 방문 여부를 체크하기 위함이다.

2. 0초는 짝수로 가정하고 시작 위치에 대한 방문여부를 체크한다.
3. 탐색시작.
4. 탐색이 시작되었으므로 1초 증가시키고 현재 큐의 사이즈를 계산하고 큐의 사이즈 만큼 루프 실행
5. 큐의 가장 앞에 위치한 원소를 꺼낸다.
6. 5에서 꺼낸 위치에서 방문할 수 있는 세가지의 위치를 계산하고 홀수초, 짝수초를 구분하여, 해당 위치가 방문할 수 있는 위치인지 확인한다.
7. 이때 방문 가능한 위치라면 홀수초 짝수초를 구분하여 방문여부를 체크하고 방문하려는 위치를 queue에 저장한다.
8. 송아지의 위치를 업데이트 한다.
9. 8번에서 업데이트한 송아지의 위치가 문제에서 제시한 범위를 벗어나는지 확인한다.
10. 8번에서 업데이트한 송아지의 위치를 바탕으로 현재 초에서 송아지를 잡을 수 있는지 홀수초 짝수초를 구분하여 visited 배열을 확인한다.

위의 내용을 바탕으로 아래와 같이 풀것이다.

1. 2차원 체크 배열을 생성하고 탐색 시작.

    ```java
    visited = new boolean[2][200001];
    return BFS(s, e);
    ```

2. 큐를 초기화하고 시작 위치를 큐에 추가한다. 그리고 시작 위치에 대한 방문 표시를 한다.

    ```java
    queue = new LinkedList<>();
    queue.offer(s);
    visited[0][s] = true;
    ```

3. 탐색을 시작하고 레벨 탐색을 위해서 큐의 사이즈를 계산한다. 그리고 1초가 지났다는 의미로 level 값을 1증하고 큐의 사이즈 만큼 루프를 실행한다.

    ```java
    int level = 0;
    while(!queue.isEmpty()){
        int len = queue.size();
        level++;
        for(int i = 0; i < len; i++){
    ```

4. 큐의 가장 앞에 위치한 원소를 꺼내고, 현재 위치에서 방문할 수 있는 위치를 계산한다.

    ```java
    int cur = queue.poll();
    for (int nx : new int[]{cur - 1, cur + 1, cur * 2}) {
    ```

5. 새롭게 방문하려는 위치가 범위 내인지 확인하고 홀수초 짝수초를 구분하여 아직 방문하지 않은 위치라면 홀수초 짝수초를 구분하여 방문 표시를 한다. 그리고 방문하려는 위치를 큐에 추가.

    ```java
    if (nx >= 0 && nx <= 200000 && !visited[level % 2][nx]) {
        visited[level % 2][nx] = true;
        queue.offer(nx);
    }
    ```

6. 송아지의 위치를 업데이트하고 문제에서 요구하는 조건을 벗어난 범위라면 -1을 리턴

    ```java
     e = e + level;
    if(e > 200000){
        return -1;
    }
    ```

7. 만약 홀수초 짝수초를 구분하여 송아지가 있는 위치에 방문할 수 있는지 확인하고 방문 가능하다면 현재 레벨(시간)을 리턴한다.

    ```java
    if (visited[level % 2][e]) {
        return level;
    }
    ```

8. 모든 탐색이 종료됬음에도 송아지를 찾지 못하였다면, 문제에서 요구하는대로 -1을 리턴

    ```java
    return -1;
    ```


### 코드

---

```java
static boolean[][] visited;
static Queue<Integer> queue;
public static int BFS(int s, int e) {
    queue = new LinkedList<>();
    queue.offer(s);
    visited[0][s] = true;
    
    int level = 0;
    while(!queue.isEmpty()){
        int len = queue.size();
        level++;
        
        for(int i = 0; i < len; i++){
            int cur = queue.poll();
            
            for (int nx : new int[]{cur - 1, cur + 1, cur * 2}) {
                if (nx >= 0 && nx <= 200000 && !visited[level % 2][nx]) {
                    visited[level % 2][nx] = true;
                    queue.offer(nx);
                }
            }
        }
        
        e = e + level;
        if(e > 200000){
            return -1;
        }
        
        if (visited[level % 2][e]) {
            return level;
        }
    }
    
    return -1;
}

public static int solution(int s, int e){
    visited = new boolean[2][200001];
    return BFS(s, e);
}
```