### 문제

---

현수가 다니는 회사는 회의실에 출입할 때 명부에 이름을 적어야 한다.

입실과 퇴실이 동시 에 이뤄지는 경우는 없으며, 입실 시각과 퇴실 시각은 따로 기록하지 않는다.

오늘 회의실에는 총 n명이 입실 후 퇴실했다.

편의상 사람들은 1부터 n 까지의 번호가 하나씩 붙어있으며, 두 번 이상 회의실에 들어온 사람은 없다.

현수는 각 사람별로 회의실에 서 반드시 만난 사람은 몇 명인지 구하려 한다.

예를 들어, 입실 명부에 기재된 순서가 [2, 1, 3], 퇴실명부에 기재된 순서가 [1, 3, 2]인 경우,

- 1번과 2번은 반드시 만난다.
- 1번과 3번은 반드시 만났는지 알 수 없다.
- 2번과 3번은 반드시 만난다.

매개변수 enter에 회의실에 입실한 순서의 사람번호 주어지고, exit에 퇴실한 순서의 사람번호 가 주어지면 각 사람별로 반드시 만난 사람은 몇 명인지 번호순서대로 배열에 담아 반환하는 프로그램을 작성하라.

### 입출력 예

---
<img width="752" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202024-04-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204 54 15" src="https://github.com/runtime-zer0/goorrrng/assets/147473025/95afe42f-7752-4981-8a35-4412adebb593">


- 입력예제 1 설명

1번 사람은 2번, 3번, 4번 사람을 모두 만난다.

2번 사람은 1번 사람만 만난다.

3번 사람은 1번과 4번 사람을 반드시 만난다.

4번 사람은 1번과 3번 사람을 반드시 만난다.

### 제한사항

---

- 2 <= n <= 100

### 문제 접근

---

어렵다.

처음 문제를 봤을때 큐를 활용하여 문제를 풀려고 했으나 풀리지 않았다.

그래서 해설을 통해서 문제를 풀었지만 그래도 이해가 쉽게 되지 않았다.

해설에서 제시하는 문제를 푸는 과정은 아래와 같았다.

1. 문제에서 주어지는 enter 값과 exit 값은 사람의 번호를 의미하므로 인덱스로 활용하기위해서 값을 1씩 감소한다.
2. **사람이 회의실에 들어온 순서를 enterIdx에 기록한다.**

    <aside>
    💡 enter[i] 값은 i 번째로 입장한 사람의 번호이므로 해당 값을 활용하여 enterIdx 값을 기록한다.

    </aside>

3. **2 에서 기록한 값을 활용하여 회의실에 들어오는 사람의 순서대로 enterTime과 exitTime을 기록한다.**

    <aside>
    💡 이때, i번째로 나가는 사람이 나가려면 i번째로 나가는 사람이 당연히 회의실에 들어와야하는것이고 i번째로 나가는 사람이 회의실에 들어오기전 이미 들어와있는 사람이 있다면 enter을 확인하여 먼저 들어온 사람의 enterTime을 0초부터 기록한다.

    </aside>

4. 3에서 기록한 enterTime과 exitTime을 바탕으로 루프를 활용하여 i, j 번째 사람이 만날수 없는 조건을 ! 연산하여 i, j 번째 사람이 만나는 조건을 만든후 해당 조건에 해당하는 i, j 번째 사람이 회의실에서 만나는 사람의 수를 각각 1씩 증가한다.

### 체크포인트

---

- **enter 값과 exit 값을 1씩 감소**

    ```java
    enter[i], exit[i] 값은 사람 번호이므로 해당 값을 활용하여 문제를 풀것이므로 인덱스와 동일하게 0 부터 시작하도록 값을 1씩 감소시킨다.
    ```

- **두사람의 회의실 입장시간과 회의실 나가는 시간이 겹치지 않는다면 두사람은 회의실에서 만나지 않은것이다.**

    ```java
    만나지 않은 조건을 부정하면 만나는 조건이되므로 두사람씩 비교하여 만나는 조건에 부합하는 사람들이라면 회의실에서 만나는 사람이므로 두사람 각각의 회의실에서 만나는 사람의 수 값을 1씩 증가시킨다.
    ```


---

위의 내용을 바탕으로 아래와 같이 풀것이다.

1. 문제에서 주어진 사람의 번호를 편하게 활용하기 위해, 인덱스와 맞추기 위해서 1씩 감소

    ```java
    for (int i = 0; i < n; i++) {
        enter[i]--;
        exit[i]--;
    }
    ```

2. 회의실에 들어온 사람의 순서를 기록하기위한 enterIdx를 생성후 기록

   enterIdx[i]의 값은 i번 사람이 회의실에 들어온 순서를 의미한다.

    ```java
    // 사람이 회의실에 들어온 순서를 기록
    int[] enterIdx = new int[n];
    // enter에 사람이 회의실에 온 순서를 기록
    for (int i = 0; i < n; i++) {
        enterIdx[enter[i]] = i;
    }
    ```

3. 각 사람의 회의에 입장한 시각을 기록하기 위한 enterTime, 각 사람이 회의실에서 퇴장한 시각을 기록하기 위한 exitTime 배열 생성

    ```java
    // 사람이 회의실에 들어온 시각을 기록
    int[] enterTime = new int[n];
    
    // 사람이 회의실에서 나가는 시각을 기록
    int[] exitTime = new int[n];
    ```

4. 루프를 활용하여 enterIdx를 활용하여 가장 먼저 나가는 사람을 회의실에서 퇴장시키기 위해 i 번째 사람이 회의실에 들어오기전 만약 먼저 회의실에 입장한 사람이 있다면 해당 사람을 먼저 회의실에 입장시킨다고 가정하고 enterTime에 회의실에 먼저 입장한 순서대로 기록한다.

   그리고 enterTime에 값의 기록이 완료되면, i번째로 회의실에서 퇴장하는 사람의 퇴장 시각을 기록한다.

    ```java
     // 루프를 돌면서 회의실을 나가는 순서대로 enterIdx 를 활용하여 회의실에 들어오는 사람의 순서대로enterTime을 기록한다.
    for (int i = 0, j = 0; i < n; i++) {
        // 루프를 활용하여 enterIdx[exit[i] 의 값은 i 번째로 나가는 사람이 들어온 순서를 의미한다.
        // i번째로 나가는 사람이 나가려면 i번째로 나가는 사람이 당연히 회의실에 들어와야하는것이고
        // i번째로 나가는 사람이 회의실에 들어오기전 이미 들어와있는 사람이 있다면
        // enter 을 확인하여 먼저 들어온 사람의 enterTime을 0초부터 기록한다.
        while (j < n && j <= enterIdx[exit[i]]) {
            enterTime[enter[j]] = time++;
            j++;
        }
        // i번째로 나가는 사람이전에 회의실에 먼저 들어오는 사람들의 회의실 입장시간을 기록했다면,
        // i번째로 나가는 사람이 나가는 시각을 기록한다.
        exitTime[exit[i]] = time++;
    }
    ```

5. 업데이트된 enterTime, exitTime 값을 바탕으로 두사람씩 비교하여 각각 회의실에서 만나게되는 사람의 수를 업데이트한다.

   i, j 의 사람을 선택해서 i가 회의실에서 나가는 시각이 j 라는 사람이 들어오는 시각보다 작거나 j가 나가는 시각이 i 가 들어오는 시각보다 작다면 이 두가지의 경우는 i와 j 가 만나지 않는다는 의미다.

   그것의 제외한 나머지 경우는 i와 j 가 만난다는 의미이므로 ! 연산을 활용하여 해당 조건을 만족한다면, i 와 j 는 서로 회의실에서 만나게 되는 것이므로 값을 1씩 증가한다.

    ```java
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (!(exitTime[i] < enterTime[j] || exitTime[j] < enterTime[i])) {
                answer[i]++;
                answer[j]++;
            }
        }
    }
    ```


### 코드

---

```java
static int[] solution(int[] enter, int[] exit) {
    int n = enter.length;
    int[] answer = new int[n];

    // 문제에서 주어진 사람의 번호를 인덱스와 맞추기 위해서 1씩 감소
    for (int i = 0; i < n; i++) {
        enter[i]--;
        exit[i]--;
    }

    // 사람이 회의실에 들어온 순서를 기록
    int[] enterIdx = new int[n];
    // 사람이 회의실에 온 순서를 기록
    for (int i = 0; i < n; i++) {
        enterIdx[enter[i]] = i;
    }

    // 사람이 회의실에 들어온 시각을 기록
    int[] enterTime = new int[n];

    // 사람이 회의실에서 나가는 시각을 기록
    int[] exitTime = new int[n];

    int time = 0;
    // 시뮬레이션 시작
    for (int i = 0, j = 0; i < n; i++) {
        // i 번째 사람이 회의실에 입장하기전에 입장한 사람들의 회의실 입장 시각 기록
        while (j < n && j <= enterIdx[exit[i]]) {
            enterTime[enter[j]] = time++;
            j++;
        }
        // i 번째로 회의실에서 나가는 사람이 회의실에서 퇴장하는 시각 기록
        exitTime[exit[i]] = time++;
    }

    // i번째, j 번째 사람이 만나지 않는 경우를 ! 연산을 통하여 만나는 조건으로 변환후 i번째, j 번째 사람이 회의실에서 만난다면 각각 1씩 증가.
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (!(exitTime[i] < enterTime[j] || exitTime[j] < enterTime[i])) {
                answer[i]++;
                answer[j]++;
            }
        }
    }

    return answer;
}
```